## 分而治之
分而治之可分为三部分
- 分解原问题为多个子问题(原问题的多个小实例)
- 解决子问题, 用返回解决子问题的方式递归算法。递归算法的基本情形可以用来解决子问题
- 组合这些子问题的解决方式,得到问题的解

二分法搜索和归并排序就是很经典的分而治之
## 动态规划
动态规划也遵循三个步骤
- 定义子问题
- 反复执行来解决子问题的部分
- 识别并求解出基线条件

> 动态规划和分而治之是不同的方法。分而治之是把问题分解成相互独立的子问题，然后组合他们的答案,而动态规划是将问题分解成相互依赖的子问题。

经典动态规划问题
- [最少硬币找零问题](./minCoinChange.js): 给出d1,d2,d3,...,dn个面值的硬币和需要找零的钱money,找出最少硬币的个数
- [背包问题](./knapSack.js): 给定一个固定大小、能够携带重量W的背包,以及一组有价值和重量的物品,找出一个最佳解决方案,使得背包总重量不超过W且价值最大
- [最长公共子序列](./lcs.js): 找出两个字符串序列的最长子序列的长度。最长子序列是指,在两个字符串序列中以同样顺序出现,但不要求连续的字符串序列。比如'acbaed'和'abcadf'最长子序列就是'acad'
   - 有两个字符串a(n),b(n)他们的最长子序列长度为n这个时候a(n)和b(n)都加一个相同的字符串'z'那么a(n+1),b(n+1)的最长相同子序列就是n+1
   - 同样是这两个字符串a(n),b(n)他们需要一个不同的字符串a(n)要加'f',b(n)要加'z'这个时候加完'f'的a是a(n+1)加完'z'的b是b(n+1)这个时候a(n+1)和b(n+1)的最长子序列就是Math.max(a(n+1)b(n),a(n)b(n+1))因为你不知道哪一个新加的字段会不会匹配上之前的字段所以取最大就好了
## 贪心算法
贪心算法遵循一种近似解决问题的技术,期盼通过每个阶段的局部最优选择(当前最好的解),从而达到全局的最优(全局最优解)。他不像动态规划算法那样计算更大的格局

- [贪心算法的硬币找零](tcoin.js): 贪心版本的比动态规划版本的简单很多,当输入`tcoin([1, 5, 10, 25], 36);`时结果是一样的,但是输入`tcoin([1, 3, 4], 6);`的时候并不是最优解`[3,3]`而是`[4,1,1]`

比起动态规划算法而言,贪心算法更简单/更快。然而就像我们所见,他并不总是得到最优解。但是综合来看,它相对执行时间来说,输出了一个可以接受的值
## 回溯算法
回溯算法是一种渐进式寻找并构建问题解决方式的策略。我们从一个可能的动作开始并尝试着用这个动作解决。如果不能解决,就回溯并选择另一个动作直到将问题解决。根据这种行为。回溯算法会尝试所有可能的动作

经典回溯问题
- [迷宫老鼠问题](./ratInAMaze.js): 假设我们有一个NxN的矩阵,矩阵的每一个位置是一个方块。每个位置(或块)可以是空闲的(值为1)或者是被阻挡的(值为0).需要找到从`[0,0]`到`[n-1,n-1]`的路径
- [骑士巡逻问题](./knightRun.js): 在8x8的国际象棋棋盘上随机在一格放上一起骑士(马),给出它巡逻完整个棋盘的路径(棋盘所有格子只能走一次)
- [N皇后问题](./nqueen.js): 如何将n个皇后放在国际象棋棋盘上,并且使这n个皇后不能相互攻击
- [数独解题器](./sudokuSolver.js): 9x9的矩阵,每行每列都是由1~9组成且数字不能相同,矩阵还包含了3x3的小方格,他们同样需要分别用这九个数字填满且不能相同,矩阵开始会填入一些数字请你把数独完成