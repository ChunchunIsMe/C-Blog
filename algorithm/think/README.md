## 分而治之
分而治之可分为三部分
- 分解原问题为多个子问题(原问题的多个小实例)
- 解决子问题, 用返回解决子问题的方式递归算法。递归算法的基本情形可以用来解决子问题
- 组合这些子问题的解决方式,得到问题的解

二分法搜索和归并排序就是很经典的分而治之
## 动态规划
动态规划也遵循三个步骤
- 定义子问题
- 反复执行来解决子问题的部分
- 识别并求解出基线条件

> 动态规划和分而治之是不同的方法。分而治之是把问题分解成相互独立的子问题，然后组合他们的答案,而动态规划是将问题分解成相互依赖的子问题。

经典动态规划问题
- [最少硬币找零问题](./minCoinChange.js): 给出d1,d2,d3,...,dn个面值的硬币和需要找零的钱money,找出最少硬币的个数
- [背包问题](./knapSack.js): 给定一个固定大小、能够携带重量W的背包,以及一组有价值和重量的物品,找出一个最佳解决方案,使得背包总重量不超过W且价值最大
- [最长公共子序列](./lcs.js): 找出两个字符串序列的最长子序列的长度。最长子序列是指,在两个字符串序列中以同样顺序出现,但不要求连续的字符串序列。比如'acbaed'和'abcadf'最长子序列就是'acad'
   - 有两个字符串a(n),b(n)他们的最长子序列长度为n这个时候a(n)和b(n)都加一个相同的字符串'z'那么a(n+1),b(n+1)的最长相同子序列就是n+1
   - 同样是这两个字符串a(n),b(n)他们需要一个不同的字符串a(n)要加'f',b(n)要加'z'这个时候加完'f'的a是a(n+1)加完'z'的b是b(n+1)这个时候a(n+1)和b(n+1)的最长子序列就是Math.max(a(n+1)b(n),a(n)b(n+1))因为你不知道哪一个新加的字段会不会匹配上之前的字段所以取最大就好了
## 贪心算法
贪心算法遵循一种近似解决问题的技术,期盼通过每个阶段的局部最优选择(当前最好的解),从而达到全局的最优(全局最优解)。他不像动态规划算法那样计算更大的格局

- [贪心算法的硬币找零](tcoin.js): 贪心版本的比动态规划版本的简单很多,当输入`tcoin([1, 5, 10, 25], 36);`时结果是一样的,但是输入`tcoin([1, 3, 4], 6);`的时候并不是最优解`[3,3]`而是`[4,1,1]`

比起动态规划算法而言,贪心算法更简单/更快。然而就像我们所见,他并不总是得到最优解。但是综合来看,它相对执行时间来说,输出了一个可以接受的值
## 回溯算法