## V8的垃圾回收机制

### 分代内存
在V8中,主要将内存分为新生代和老生代两代。新生代中的对象为存活时间较短的对象,老生代中的对象为存活时间较长或常驻内存的对象。

![分代内存](./pic/1.png)

默认情况下 64 位系统下只能使用 1464MB, 32 位则为 732MB
#### 新生代
新生代中的对象主要通过 Scavenge 算法。 Scavege 算法的具体实现中,主要采用了 Cheney 算法。

Cheney 算法是一种采用复制的方式实现的垃圾回收算法。会将堆内存一分为二,每一部分空间称为 semispace 正在使用的 semispace 空间称为 From 空间。处于空闲的闲置状态的空间叫做 To 空间。当我们分配对象时,先是在 From 空间中进行分配。当进行垃圾回收时,会检查 From 空间中的存货对象, 这些存活对象将赋值到 To 空间,而非存活对象占用的空间就会被释放。而非存活对象占用的空间将会被释放。完成复制之后 From 和 To 空间就会发生对换。

1. semispace 空间分配
![新生代空间分配](./pic/new1.png)

2. 将活跃对象从 From 空间复制到 To 空间
![新生代空间复制](./pic/new2.jpg)

3. 清空From空间全部内存,然后将 From/To 空间对调
![新生代空间对调](./pic/new3.jpg)

- 缺点: 只能使用堆内存的一半,这是由于复制机制和划分空间所决定的。
- 优点: 值复制存活的对象,并且对生命周期短的场景存活对象只占少部分,所以时间效率上有优异的表现
#### 晋升
在单纯的 Scavenge 过程中,Form空间中的存活对象会被赋值到 To 空间中去, 然后对 From 空间和 To 空间进行对换。但在一定条件下,需要将存活周期长的对象移动到老生代中,也就是完成对象的晋升。

在默认情况下,V8的对象分配主要集中在 From 空间中。对象从 From 空间复制到 To 空间时,会检查它的内存地址来判断这个对象是否已经经历过一次 Scavenge 回收。如果经历过了,会将该对象从 From 空间复制到老生代空间中。如果没有就复制到 To 空间中。

![默认晋升](./pic/up1.png)

另一个判断方式是 To 空间的内存占用比。当要从 From 空间复制一个对象到 To 空间时, 如果 To 空间已经使用了超过 25%。则这个对象直接晋升到老生代空间中。设置 25% 这个限制值的原因是当这次 Scavange 回收完后, To 空间将会变成 From 空间。如果占比过高, 会影响后续内存分配。

![内存占用比晋升](./pic/up2.png)

#### 老生代
- Mark-Sweep (标记清除)

因为老生代对象中,存活对象较多,所以不采用 Scavenge,一是浪费空间,二是如果有长时间存在的对象时算法很不适用。

而标记清除分为标记和清除两个阶段,在标记阶段遍历堆中所有对象,并标记活着的对象,而在清除阶段,只清除没有被标记的对象。这和 Scavenge 的区别就在于,标记清除只清除死亡对象而 Scavenge 只复制活着的对象。而原因是因为死对象在老生代只占少部分,而新生代活对象只占少部分。

- Mark-Compact (标记整理)

标记清除最大的问题就是在进行一次标记清除回收之后,内存空间会存在不连续的状态。这种内存碎片会对后续的内存分配问题造成问题,因为很可能出现需要分配一个大对象而空余的空间都是碎片化的。如果所有的碎片空间都没办法完成这次分配,就会提前触发垃圾回收,而这次回收是不必要的。

而为了解决内存碎片的问题Mark-Compact就被提出了。它是在 Mark-Sweep 的基础上演变出来的。它们的差别在于对象在标记为死亡后,在整理的过程中,将活着的对象往一端移动,移动完成之后,直接清除掉边界外的内存。

- Incremental Marking (增量标记)