## V8的垃圾回收机制

### 分代内存
在V8中,主要将内存分为新生代和老生代两代。新生代中的对象为存活时间较短的对象,老生代中的对象为存活时间较长或常驻内存的对象。

![分代内存](./pic/1.png)

默认情况下 64 位系统下只能使用 1464MB, 32 位则为 732MB
#### 新生代
新生代中的对象主要通过 Scavenge 算法。 Scavege 算法的具体实现中,主要采用了 Cheney 算法。

Cheney 算法是一种采用复制的方式实现的垃圾回收算法。会将堆内存一分为二,每一部分空间称为 semispace 正在使用的 semispace 空间称为 From 空间。处于空闲的闲置状态的空间叫做 To 空间。当我们分配对象时,先是在 From 空间中进行分配。当进行垃圾回收时,会检查 From 空间中的存货对象, 这些存活对象将赋值到 To 空间,而非存活对象占用的空间就会被释放。而非存活对象占用的空间将会被释放。完成复制之后 From 和 To 空间就会发生对换。

1. semispace 空间分配
![新生代空间分配](./pic/new1.png)

2. 将活跃对象从 From 空间复制到 To 空间
![新生代空间复制](./pic/new2.jpg)

3. 清空From空间全部内存,然后将 From/To 空间对调
![新生代空间对调](./pic/new3.jpg)

- 缺点: 只能使用堆内存的一半,这是由于复制机制和划分空间所决定的。
- 优点: 值复制存活的对象,并且对生命周期短的场景存活对象只占少部分,所以时间效率上有优异的表现
#### 晋升
在单纯的 Scavenge 过程中,Form空间中的存活对象会被赋值到 To 空间中去, 然后对 From 空间和 To 空间进行对换。但在一定条件下,需要将存活周期长的对象移动到老生代中,也就是完成对象的晋升。

在默认情况下,V8的对象分配主要集中在 From 空间中。对象从 From 空间复制到 To 空间时,会检查它的内存地址来判断这个对象是否已经经历过一次 Scavenge 回收。如果经历过了,会将该对象从 From 空间复制到老生代空间中。如果没有就复制到 To 空间中。

![默认晋升](./pic/up1.png)

另一个判断方式是 To 空间的内存占用比。当要从 From 空间复制一个对象到 To 空间时, 如果 To 空间已经使用了超过 25%。则这个对象直接晋升到老生代空间中。设置 25% 这个限制值的原因是当这次 Scavange 回收完后, To 空间将会变成 From 空间。如果占比过高, 会影响后续内存分配。

![内存占用比晋升](./pic/up2.png)

#### 老生代
- Mark-Sweep (标记清除)

因为老生代对象中,存活对象较多,所以不采用 Scavenge,一是浪费空间,二是如果有长时间存在的对象时算法很不适用。

而标记清除分为标记和清除两个阶段,在标记阶段遍历堆中所有对象,并标记活着的对象,而在清除阶段,只清除没有被标记的对象。这和 Scavenge 的区别就在于,标记清除只清除死亡对象而 Scavenge 只复制活着的对象。而原因是因为死对象在老生代只占少部分,而新生代活对象只占少部分。

- Mark-Compact (标记整理)

标记清除最大的问题就是在进行一次标记清除回收之后,内存空间会存在不连续的状态。这种内存碎片会对后续的内存分配问题造成问题,因为很可能出现需要分配一个大对象而空余的空间都是碎片化的。如果所有的碎片空间都没办法完成这次分配,就会提前触发垃圾回收,而这次回收是不必要的。

而为了解决内存碎片的问题Mark-Compact就被提出了。它是在 Mark-Sweep 的基础上演变出来的。它们的差别在于对象在标记为死亡后,在整理的过程中,将活着的对象往一端移动,移动完成之后,直接清除掉边界外的内存。

|回收算法|Mark-Sweep|Mark-Compact|Scavenge|
|:---:|:--:|:---:|:---:|
|速度|中等|慢|最快|
|空间开销|少(有碎片)|少(无碎片)|双倍空间(无碎片)|
|是否移动对象|否|是|是|

可以看到, 在 Mark-Sweep 和 Mark-compact 之间, 由于 Mark-Compact 需要移动对象,所以它的执行速度不会很快。所以在取舍上 V8 主要使用 Mark-Sweep,在空间不足以对从新生代晋升过来的对象进行分配时才使用 Mark-Compact

- Incremental Marking (增量标记)
为了避免出现 JavaScript 应用逻辑和垃圾回收器看到不一样的情况, 垃圾回收的 3 种基本算法都需要将应用逻辑停下来, 待执行完垃圾回收后再恢复执行应用逻辑, 这种行为被称为 "全停顿"(stop-the-world)。在 V8 的分代式垃圾回收中, 一次小垃圾回收只影响新生代, 因为存活对象少所以全停顿也影响不大。 但是老生代中存活对象较多较大, 全停顿起来就会比较恐怖需要改善。

为降低全堆垃圾回收带来的停顿时间, V8 从标记阶段入手, 将原本要一口气停顿完成的动作改为增量标记, 就是拆分为小 "步进", 每做完一 "步进" 就让 JavaScript 逻辑执行一小会儿。 垃圾回收与应用逻辑交替执行直到标记完成。

V8 在经过增量标记后, 垃圾回收的最大停顿时间可以减少到原来的 1/6 左右

V8 还引入了延迟清理(lazy sweeping) 和增量式整理(incremental compaction), 让清理和整理也变成增量式的。 同时还引入并行标记和并行清理, 进一步利用多核性能降低每次停顿的时间。

### GC的触发规则
我们可以从之前的结论得到:

- 当程序触发内存申请时, 浏览器会检测是否到达一个临界值再进行触发GC, 申请小内存时(新生代), 申请大内存时, 可能触发标记清除或者标记整理
- 老生代GC时间和老生代对象数量成正比。