## 行为型模式
### 命令模式（Command）
定义: 将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。简单来说就是不直接调用类的内部方法，而是通过"指令函数"传递参数，由"指令函数"来调用类的内部方法。

> 在这过程中，分别有3个不同的主体: 调用者、传递者和执行者

应用场景:想要降低调用者和执行者之间的耦合度时，可以使用此种设计模式。例如: 设计一个命令队列，将命令调用记入日志

### 备忘录模式（Memento）
定义: 保存某个状态，并且在需要的时候直接获取，而不是重新计算。

> 注意: 备忘录模式实现，不能破坏原始封装。也就是说，能拿到内部状态，将其保存在外部。

应用场景: 最经典的例子就是"斐波那契数列"递归实现。不借助备忘录模式，数据一大，就容易爆栈；借助备忘录，算法的时间复杂度可以降低到o(n)
### 模板模式（Template Method）
定义: 抽象父类定义了子类需要重写的相关方法。并且这些方法，仍然是通过父类方法调用的。父类提供”模板“并且决定是否调用，子类进行具体实现。

应用场景: 一些系统的架构或者算法骨架。
### 状态模式（State）
定义: 对象行为是根据状态改变而改变的。正是由于内部状态的变化，导致对外的行为发生了变化。

例子: 相同的方法在不同时刻调用，行为可能不同

优点: 
  - 封装了转化规则，对于大量的分支语句，可以考虑使用状态类进行进一步封装。
  - 每个状态都是确定的，对象行为是可控的

缺点: 状态模式的实现关键是将事务的状态都封装成单独的类，这个类的各种方法就是"此种状态对应的表现行为"。因此程序开销会增大。

运用场景: promise就是很经典的状态模式,当promise状态不一样的时候，调用then的行为是不一样的
### 策略模式（Strategy）
定义: 就是能够把一系列"可互换的"算法封装起来，并根据用户需求来选择其中一种。

实现核心: 将算法的使用和算法的实现分离。算法的实现交给策略类。算法的使用交给环境类，环境类会根据不同的情况选择合适的算法。

需要了解所有"策略"的异同点，才能选择合适的"策略"进行调用

运用场景: redux就是很经典的策略模式，reducer是策略类 dispatch是环境类
### 解释器模式（Interpreter）
定义: 提供了评估语言的语法或者表达式的方式。

核心: 
  1. 抽象表达式: 主要有一个`interpret()`操作
    - 终结符表达式: `R = R1 + R2`中, `R1 R2`就是终结符
    - 非终结符表达式: `R = R1 - R2`中, `R1 R2`就是非终结符
  2. 环境(context): 存放文法中各个终结符所对应的具体值。比如前面`R1`和`R2`的值


优点: 每个文法规则可以表述为一个类或者方法。这些文法互相不干扰，符合"开闭原则"。

缺点: 由于每条文法都需要构建一个类或者方法，文法数量上去之后，很难维护。而且，语句的执行效率很低
### 发布-订阅模式（public-Subscribe）
定义: 定义了对象之间一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖它的对象都可以得到通知。

发布订阅模式和观察者模式概念类似，但是在发布-订阅模式中，订阅者和发布者之间多了一个中间件: 一个被抽象出来的信息调度中心。

同样redux也用到了发布-订阅模式
### 责任链模式（Chian of Responsibility）
定义: 多个对象均有机会处理请求，从而解除发送者和接受者之间的耦合关系。这些对象连接成为链式结构，每个节点转发请求，直到有对象处理请求为止。

核心思想: 请求者不知道是哪个节点对象处理的请求。如果当前不符合终止条件，那么把请求转发给下一个节点处理。

> 而当需求具有"传递"性质时(代码中其中一种体现就是: 多个`if/else`嵌套)，这个时候就可以考虑将每个分支拆分成一个节点对象，拼接成责任链。

优点: 
  - 可以根据需求变动，任意向责任链中添加/删除节点对象
  - 没有固定的"开始节点"，可以从任意节点开始

缺点: 责任链最大的代价就是每个节点带来多余的消耗。当责任链过长，很多节点只有传递的作用，而不是真正的处理逻辑
### 迭代器模式（Iterator）
定义: 迭代器模式是指提供一种方法顺序访问一个集合对象的各个元素，使用者不需要了解集合对象的底层实现。

内部迭代器: 封装的方法完全接手迭代过程，外部只需要一次调用

外部迭代器: 用户必须显示地请求迭代下一元素

generator 就是一个很明显的迭代器模式