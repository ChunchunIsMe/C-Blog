## 行为型模式
### 命令模式（Command）
定义: 将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。简单来说就是不直接调用类的内部方法，而是通过"指令函数"传递参数，由"指令函数"来调用类的内部方法。

> 在这过程中，分别有3个不同的主体: 调用者、传递者和执行者

应用场景:想要降低调用者和执行者之间的耦合度时，可以使用此种设计模式。例如: 设计一个命令队列，将命令调用记入日志

### 备忘录模式（Memento）
定义: 保存某个状态，并且在需要的时候直接获取，而不是重新计算。

> 注意: 备忘录模式实现，不能破坏原始封装。也就是说，能拿到内部状态，将其保存在外部。

应用场景: 最经典的例子就是"斐波那契数列"递归实现。不借助备忘录模式，数据一大，就容易爆栈；借助备忘录，算法的时间复杂度可以降低到o(n)
### 模板模式（Template Method）
定义: 抽象父类定义了子类需要重写的相关方法。并且这些方法，仍然是通过父类方法调用的。父类提供”模板“并且决定是否调用，子类进行具体实现。

应用场景: 一些系统的架构或者算法骨架。
### 状态模式（State）
定义: 对象行为是根据状态改变而改变的。正是由于内部状态的变化，导致对外的行为发生了变化。

例子: 相同的方法在不同时刻调用，行为可能不同

优点: 
  - 封装了转化规则，对于大量的分支语句，可以考虑使用状态类进行进一步封装。
  - 每个状态都是确定的，对象行为是可控的

缺点: 状态模式的实现关键是将事务的状态都封装成单独的类，这个类的各种方法就是"此种状态对应的表现行为"。因此程序开销会增大。

运用场景: promise就是很经典的状态模式,当promise状态不一样的时候，调用then的行为是不一样的
### 策略模式（Strategy）
定义: 就是能够把一系列"可互换的"算法封装起来，并根据用户需求来选择其中一种。

实现核心: 将算法的使用和算法的实现分离。算法的实现交给策略类。算法的使用交给环境类，环境类会根据不同的情况选择合适的算法。

需要了解所有"策略"的异同点，才能选择合适的"策略"进行调用

运用场景: redux就是很经典的策略模式，reducer是策略类 dispatch是环境类
### 解释器模式（Interpreter）

### 发布-订阅模式（public-Subscribe）
### 责任链模式（Chian of Responsibility）
### 迭代器模式（Iterator）