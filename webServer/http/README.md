## http
HTTP协议是 HyperText Transfer Protocol(超文本传输协议)的缩写, 它是互联网上应用最为广泛的一种网络协议。所有的 WWW 文件都必须遵循这个标准。

并且http请求由三部分构成
- 请求行
- 首部
- 实体

请求行`GET /images/logo.gif HTTP/1.1`,大概由请求方法、URL、协议版本组成
### http请求方法
请求方法分很多种,最常用的就是`get`和`post`了。那这两种方法有什么不同呢？

首先引入副作用和幂等的概念
1. 副作用指对服务器上的资源做改变,搜索是无副作用的,注册是副作用的
2. 幂等指发送 M 和 N 次请求(两者不同且大于1), 服务器上的资源状态一致, 比如注册 10 个和 11 个账号是不幂等的(服务器多了一个账号),对文章修改 10 次和 11 次是幂等的(服务器只是更新同一个资源)

所以
1. 在规范上说: Get多用于无副作用,幂等的情景,例如搜索关键字。post多用于副作用,不幂等的场景,比如注册
2. 在技术上说: 
  - Get 请求能缓存,Post 不能(有些浏览器会做处理)
  - Post相对于Get安全一点,因为Get请求都包含在URL中,并且会被浏览器保存历史记录。Post不会
  - 浏览器URL有长度限制,会影响GET传参
  - Post有更多的编码格式且不对数据类型限制
### http1.0/1.1 的区别
- 缓存处理: 在HTTP1.0中主要使用header中的 If-Modified-Since 和 Expires来作为缓存的标准,HTTP1.1引入了If-None-Math、ETag等更多可供选择的缓存头来控制缓存策略
- 带宽优化和网络连接的使用: HTTP1.1请求头中引入了range头域,允许之请求资源的某个部分,状态码返回206
- 错误通知的管理: HTTP1.1新增了24个错误状态响应码
- Host头的处理: 在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址,因此请求消息中的URL并没有传递主机名(hostname)。但随着虚拟主机技术的发展, 在一台物理机上可能存在多台虚拟主机,并且他们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域,且请求消息中如果没有Host透雨会报400
- 长连接: HTTP1.1支持`Connection: keep-alive`一定程度弥补了HTTP1.0每次请求都要创建连接的缺点
### http1.x 的缺陷
- 连接无法复用: 连接无法复用会导致每次请求都要经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显,慢启动则对大量小型文件请求影响较大(没有达到最大窗口就被终止)
   - HTTP/1.0 传输数据时,每次都需要重新建立连接,增加延迟。
   - HTTP/1.1 虽然加入了keep-alive可以复用一部分连接, 但域名分片等情况仍然需要建立多个 connection, 耗费资源, 给服务器带来性能压力。并且Keep-Alive的复用是串行的,复用的Http请求只有等上一个Http请求结束之后才能进行。这样一个请求延时了会影响到所有请求
- HTTP1.x 使用时,header携带的内容过大,一定程度上增加了传输的成本,并且每次请求header基本不变化,会增加很多不必要的流量
- 传输都是明文,客户端和服务端无法验证对方身份,无法保证安全性
- Head-Of-Line Blocking(HOLB线头阻塞): 导致带宽无法被充分利用, 以及后续健康请求被阻塞.
   - http/1.0: 下个请求必须在前一个请求返回后才能发出,request-response对序发生。显然如果上个请求长时间没返回那么接下来的请求全部阻塞了。
   - http/1.1: 尝试使用pipeling来解决,即浏览器可以一次性发多个请求(同个域名,同一条TCP链接)。但pipeling要求返回是按序的,那么前一个请求如果很耗时,那么后面的请求即使服务器已经处理完,仍然会等待前面的请求处理完才开始按序返回。
### SPDY
2020年Google提出了SPDY(发音同"speedy")的方案,它综合了HTTPS和HTTP两者优点主要解决
- 减低延时(多路复用): 多路复用通过多个请求stream共享一个TCP连接的方式,降低多个TCP的延迟提高了带宽的利用率
- 请求优先级: 多路复用带来的新问题是,在连接共享基础之上可能有重要请求被阻塞,所以允许给每个请求设置优先级
- header压缩: 可以压缩头部
- 基于HTTPS的加密传输协议: 保留了HTTPS的TLS加密特性,提高了传输数据的可靠性
- 服务端推送: 比如请求index.html会将index.js推送给客户端,当客户端尝试获取的时候就可以直接使用缓存了。

SPDY协议在谷歌浏览器上证明可行之后,就被当做了HTTP/2的基础,主要特性都在HTTP/2之中得到继承
### http2.0
概念
- 流: 流是连接中的虚拟通道,可以承载双向的消息,每一个流都有一个唯一的整数标识符
- 消息: 是逻辑上的http消息,比如请求、响应等,由一个或多个帧组成
- 帧: http2.0通信的最小单位,没个帧包含首部,至少也会标识出当前帧所属的流,承载这特定类型的数据,比如HTTP首部、负荷等等

首先http2.0协议本身没有要求必须基于https部署,但是因为下面的原因,http2.0和https几乎都是捆绑在一起的
- http 数据明文传输,数据很容易被中间节点窥视或篡改,https可以保证数据传输的保密性、完整性和不被冒充
- 因为https对中间节点的保密,所以具有更好的连通性。基于https部署的新协议具有更高的连接成功率
- 当前主流浏览器只支持基于https部署的http2

新特性
- 二进制传输: 采用二进制传输而非http1.x的文本格式,二进制协议解析起来更高效。HTTP/1的请求和响应报文,都是由起始报文,首部和实体正文组成,各部分由文本换行符分割。HTTP2将请求和响应数据分割为更小的帧,并且它们采用二进制编码。
- 多路复用: 多路复用很好的解决了浏览器限制同一个域名下请求数量的问题,通知也接更容易实现全速传输,毕竟每次三次握手之后都要慢开始