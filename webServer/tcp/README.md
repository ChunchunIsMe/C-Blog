## tcp
- TCP 和 UDP的区别相当大。它充分的实现了数据传输时的各种控制功能,可以进行丢包时的重发控制,可以堆次序乱掉的包进行顺序控制。而这些在UDP中都没有。
- 此外,TCP作为一种面向有连接的协议,只有在确认通信对端存在时才会发送数据,从而可以控制通信流量的控制
- 根据TCP这些机制,在IP这种无连接的网络上也能实现高可靠性的通信(主要通过校验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现)

### TCP头部
对于TCP头部来说,有几个很重要的字段

- Sequence number(seq): 这个序号保证了TCP传输的报文都是有序的,对端可以通过序号顺序的拼接报文
- Acknowledegment number(ack): 这个需要表示接受端期望接收的下一个字节的编号是多少,同时也表示上一个序号的数据已经收到,这个值是上个服务端的包的 Sequence number + 1
- Window Size: 窗口大小,表示还能接受多少字节的数据,用于流量控制
- 标识符
   - SYN = 1: 当 SYN=1,ACK=0时, 说明是一个请求报文, 当 SYN=1,ACK=1时说明是一个同意建立连接的应答报文 
   - ACK = 1: 当 ACK=1 时表示确认号字段有效。此外, TCP还规定在连接后所有报文段都必须把ACK=1
   - FIN = 1: 该字段表示此报文是一个释放连接的请求报文
   - URG = 1: 该字段为1时, 表示本数据报的数据部分含紧急信息, 是一个高优先级的数据报文, 此时紧急指针有效。紧急数据一定位于当前数据包的最前面, 紧急指针标明了紧急数据的尾部
   - PSH = 1: 该字段为1时, 表示接收端应该立即将数据 push 给应用层,而不是等到缓冲区满后再提交。
   - RST = 1: 该字段为1时, 表示当前TCP连接出现严重问题,需要重新建立TCP连接, 也可以用于拒绝非法报文段和拒绝连接的请求

### 状态机
HTTP是无连接的,所以作为下层的TCP协议也是无连接的,虽然看似TCP将两端连接了起来,但是其实只是两端共同维护了一个状态。

#### 三次握手建立连接
首先三次握手的原因: 避免失效的报文被服务端接受,从而产生错误。因为如果两次就可以的话,存在第一次握手因为网络延时,引发了客户端超时重传,这个时候第二次握手之后就开始了传输,而在传输过程中如果网络延时的包到了,服务器又会以为是有一个新的连接,所以重新发一个第二次握手的包之后开始传输数据,而这次传输的数据是不必要的,这样会造成资源的浪费,所以我们需要第三次握手来确认这次传输的数据是需要的。

首先客户端和服务端都是 CLOSE 状态

- 第一次握手: 客户端给服务端发送一个 SYN=1,seq=x 的数据包来建立连接,此时客户端的状态变为 SYN-SENT(同步已发送)
- 第二次握手: 当服务端收到第一次握手的数据包后, 将发送一个 SYN=1,ACK=1,seq=j,ack=x+1 的数据包来答复, 此时服务端的状态变为 SYN_RCVD(同步收到)
- 第三次握手: 当客户端收到第二次握手的数据包时, 将发送一个 ACK=1,seq=x+1,ack=j+1 的数据包来答复, 此时客户端的状态变为 ESTAB_LISTED(已经建立连接) 而服务端收到第三次握手的包之后也进入 ESTAB_LISTEND 的状态,自此连接创建完毕开始传输数据

从此时之后到连接结束所有的包的ACK都为1,感觉这像一个答复字段,答复你收到消息了,而seq和ack的存在也保证了数据包的有序存在。

![三次握手](./pic/3connect.png)
#### 四次挥手
会有四次挥手的原因: 发送关闭连接的一方收到关闭消息之后,需要答复,而答复之后可能还会有数据包没发送完需要发送,等发送完则发送,关闭连接的数据包,再次答复,则有了四次挥手

挥手前客户端和服务器端都是 ESTAB_LISTED 状态
- 第一次挥手: 客户端发送 FIN=1,seq=u的数据包,此时客户端的状态变为 FIN_WAIT_1
- 第二次挥手: 服务器收到消息之后发送一个 ACK=1,seq=k,ack=u+1的数据包,服务器的状态变为CLOSE_WAIT,随后服务器开始发送还未发送完的数据
- 第三次挥手: 当服务器发送完最后的数据后,会发送一个FIN=1,seq=u+1,ack=k+1的数据包,告诉客户端需要关闭连接,此时服务器端的状态变为 LAST_ACK
- 第四次挥手: 当收到第三次挥手的数据包后,发送一个ACK=1,seq=k+1,ack=u+2的数据包,告诉客户端可以进行关闭连接,此时客户端进入TIME_WAIT状态,等待2ms之后客户端变为CLOSE状态,而服务器收到第四次挥手的数据包后就直接变为了CLOSE状态

等待2MSL的原因是因为害怕服务器没有收到关闭的确认消息而导致一直无法关闭连接的状态,所以等待2MSL,这2MSL是两倍的最长报文段的寿命。

MSL: 最长报文段寿命,在网络上存在的最长时间,超过这个时间报文将被丢弃。
2MSL:
![四次握手](./pic/4fin.png)
